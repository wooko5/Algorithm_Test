# 0 : 정보과학관
# 1 : 전산관
# 2 : 미래관
# 3 : 신앙관
# 4 : 한경직기념관
# 5 : 진리관
# 6 : 영남공학관
# 7 : 학생회관
# 몰랐던 점: dp를 이렇게 풀 수도 있구나, 첨 알았다, 점화식이라기 보단 굉장히 노동력있는 코드였다
def next(state):
    temp = [0 for _ in range(8)] # 건물이 8개라서 임시로 생성한 배열
    temp[0] = state[1] + state[2] # '정보과학관'을 1분 안에 산책할 수 있는 경우의 수는 인접한 '전산관'이나 '미래관'에서 가는 것뿐이다
    temp[1] = state[0] + state[2] + state[3] # '전산관'을 1분 안에 산책할 수 있는 경우의 수는 인접한 '정보과학관'이나 '미래관'이나 '신앙관'에서 가는 것뿐이다
    temp[2] = state[0] + state[1] + state[3] + state[4]
    temp[3] = state[1] + state[2] + state[4] + state[5]
    temp[4] = state[2] + state[3] + state[5] + state[6]
    temp[5] = state[3] + state[4] + state[7]
    temp[6] = state[4] + state[7]
    temp[7] = state[5] + state[6]
    for i in range(8):
        temp[i] %= 1000000007 # 나중에 아니라 먼저 나눠주면 연산이 더 빨라진다(20배 빨라짐)
    return temp # 더하기나 빼기 곱셈보다 나누기가 연산이 30~100배 더 많기 때문

dp = [1, 0, 0, 0, 0, 0, 0, 0] # 0분에 어떤 지점에 도착할 수 있는 상태
for _ in range(int(input())):
    dp = next(dp)
print(dp[0])
# 마지막에 1000000007, 1000000009 와 같은 수로 나눈 나머지를 답으로 제출하라고 하는 문제가 종종 있는데, 
# 이 수는 소수이고 어떤 답에 대한 해시값을 출력하라는 의미이다.
# C에서는 수가 커지면 int overflow를 방지하기 위한 방법으로 나머지 출력하라고 하는 경우고 있는데,
# 파이썬은 수의 범위가 어느정도 크기때문에 마지막에 나눠주면 된다. (C, Java의 경우 각 연산에 대하여 나머지를 연산 필요)
# 하지만 속도 측면에서 나눗셈연산이 상당히 무거워서 나눗셈 연산을 많이 하는게 좋은 방법은 아니지만
# 속도면에서 미리 나눗셈 연산을 해주면 나중에 큰 수의 나눗셈을 수행하는 것 보다 효율적인 결과를 볼 수 있다. 